---
title: "Assignment 2 BCB 420"
subtitle: "Differential Gene Analysis for of NPHS2 Point Variants"
author: "Anna T. Lai"
date: "`March 13, 2024`"
output:
  html_document:
    toc: true
    toc_depth: 2
bibliography: assignment_reference.bib
csl: biomed-central.csl
nocite: '@*'
---

# Setup

```{r setup, message=FALSE, warning=FALSE, results='hide'}
packages_to_install <- c("BiocManager", "RSQLite", "readr", "gplots", "reshape2", "RColorBrewer", "grid", "BiocManager", "knitr", "kableExtra", "devtools")
for (package in packages_to_install) {
  if (!requireNamespace(package, quietly = TRUE)) {
    install.packages(package)
  }
  library(package, character.only = TRUE)
}

packages_to_install <- c("edgeR", "biomaRt", "GEOquery")
for (package in packages_to_install) {
  if (!requireNamespace(package, quietly = TRUE)) {
    BiocManager::install(package)
  }
}

packages_to_install <- c("crsh/citr") #Use Zotero for citation
for (package in packages_to_install) {
  if (!requireNamespace(package, quietly = TRUE)) {
    devtools::install_github(package)
  }
}

# library(GEOmetadb) # Doesn't work anymore
library(BiocManager)
library(RSQLite)
library(readr)
library(utils)
library(base)
library(dplyr)
library(gplots)
library(reshape2)
library(RColorBrewer)
library(grid)
library(edgeR)
library(biomaRt)
library(knitr)
library(kableExtra)
library(GEOquery)
library(devtools)
```

# Information from previous assignment

About the data (with reference to lecture 4)
```{r get_data, warning=FALSE, message=FALSE}
data_geoid <- "GSE205647"
gse <- getGEO(data_geoid ,GSEMatrix=FALSE)
gse@header$overall_design
```

Un-comment to download the files to local PC. The files are already included in the GitHub repo, just in case.There are two files in this dataset and we use the counts data.
```{r files, warning=FALSE, message=FALSE}
sfilenames = getGEOSuppFiles(data_geoid,
fetch_files = FALSE)
sfilenames

# Extract zipped files in the format of gz
# extract_gz <- function(file_path) {
#   message("Extracting:", basename(file_path))
#   extracted_file_name <- gsub(".gz", "", file_path)
#   
#   if (!file.exists(extracted_file_name)){
#     gunzip(file_path)
#   }
# }
# 

# for (filename in sfilenames$fname) {
#   file_path <- file.path(getwd(), filename)
#   if (file.exists(file_path) && file.info(file_path)$size > 0) {
#     extract_gz(file_path)
#   }
# }
```

```{r read_file, warning=FALSE}
files <- c("GSE205647_counts.txt", "GSE205647_genes.txt")

counts_data <- read.table(files[1], header = TRUE)
genes_data <- read.table(files[2], header = TRUE)
```


```{r identical_files}
sorted_counts_data <- counts_data[order(counts_data$Gene.ID, counts_data$Chrom), ]
sorted_genes_data <- genes_data[order(genes_data$Gene.ID, genes_data$Chrom), ]

sorted_first_four_cols_of_counts_data <- sorted_counts_data[, 1:4]
names(sorted_first_four_cols_of_counts_data) <- c("Gene.ID", "Chrom", "Gene.Name", "Biotype")
names(sorted_genes_data) <- c("Gene.ID", "Chrom", "Gene.Name", "Biotype")

attr(sorted_first_four_cols_of_counts_data, "row.names") <- NULL
attr(sorted_genes_data, "row.names") <- NULL

all.equal(sorted_first_four_cols_of_counts_data, sorted_genes_data)
```
From the above, we conclude that genes.txt. is a subset of counts.txt. We will move on to only investigate counts.txt.

#### Rename the column name for easier identification.
All the samples were processed on December 28, 2021. The method of processing sequence read is Transcription Start Site Trimmed RNA (TSStrimRNAs).
```{r rename_columns}
rm_prefix <- "X211101_A01221_0077_"
rm_suffix <- "\\.20211028_TSStrmRNA$"

new_col_names <- sub(paste0("^", rm_prefix), "", colnames(counts_data))

new_col_names <- sub(rm_suffix, "", new_col_names)
colnames(counts_data) <- new_col_names 
```

## Data cleaning

### Remove gene with no expression at all in all conditions; Final Coverage{#coverage}
```{r remove_no_exp}
before_no <- dim(counts_data)[1]
selected_columns <- counts_data[, 5:ncol(counts_data)]
row_sums <- apply(selected_columns, 1, sum)
rows_to_keep <- row_sums > 1
filtered_counts_data <- counts_data[rows_to_keep,]
counts_data <- filtered_counts_data # for the ease of coding in the following sections

nrow(counts_data)
```
The number of genes remained after removing the genes without expression is `r nrow(filtered_counts_data)`. Before removing genes with no expression at all is `r before_no`. The difference is `r nrow(filtered_counts_data) - before_no`.

```{r remove_low_count}
subset_data <- counts_data[, 5:ncol(counts_data)]
min_num_samples <- ncol(counts_data)/2
data_matrix <- as.matrix(subset_data)

keep = rowSums(cpm(data_matrix) >1) > min_num_samples
filtered_data_matrix= data_matrix[keep,]
counts_data <- counts_data[keep,]

nrow(counts_data)
```
Choose min number of samples to roughly half of the column numbers so that there's some comparison. This reduced the number of genes of interest to `r nrow(counts_data)`. This is my final coverage.

### Investigate gene dupication in the file {#rep}
 
```{r duplicate}
# print duplicate count by Gene.ID
duplicates_count <- counts_data%>% 
  group_by(Gene.ID) %>% 
  mutate(duplicate_count = n()) %>% 
  filter(duplicate_count > 1)

print(nrow(duplicates_count))

# print duplicate count by Gene.Name
duplicates_count <- counts_data %>% 
  group_by(Gene.Name, Chrom) %>% 
  mutate(duplicate_count = n()) %>% 
  filter(duplicate_count > 1) %>% 
  summarize(duplicate_count = n_distinct(Gene.ID))%>%
  arrange(desc(duplicate_count))

duplicates_count
length(unique(duplicates_count$Gene.Name))
```

From the above we see that there is no gene with the same Ensembl ID. Each of them are unique. However, there are `r length(unique(duplicates_count$Gene.Name))` genes duplicates when grouped by gene symbol. Upon further investigation, some of the gene are located at a different chromosome, hence, the number of duplication of gene paired chromosome location is calculated. The number is `r nrow(duplicates_count)`.

At this stage, since each gene has an unique Ensembl ID, we will not discard any gene from the `r nrow(filtered_counts_data)` gene pool.


### Visualizations 
Most of the genes in the list are protein encoding.

```{r biotype}
biotype_tabulation <- table(counts_data$Biotype)
biotype_df <- data.frame(Biotype = names(biotype_tabulation), Count = as.vector(biotype_tabulation))

biotype_df<- biotype_df %>% 
  arrange(desc(Count))

biotype_df %>% 
  kable(caption = "Descending Sorting by Count") %>% 
  kable_styling(position = "center")

```

```{r visual _heatmap, fig.height = 18, fig.width = 26, warning=FALSE}
# Subset the data
subset_data <- counts_data[, 5:ncol(counts_data)]
rownames(subset_data) <- counts_data$Gene.ID

ds <- data.frame(subset_data)
rn <- counts_data[,3]
cn <- colnames(subset_data)
x <- data.matrix(ds, rownames.force = FALSE)

par(fig = c(0, 1, 0, 1), mar = c(5.1, 4.1, 4.1, 8.1))
x_log <- log2(x)
x_log[which(x_log == -Inf)] <- 0

hm <- heatmap(x_log, Rowv = NA, Colv = NA, margins = c(5, 10), col = colorRampPalette(rev(brewer.pal(9, "YlOrBr")))(256), scale = "none", dendrogram = "none", xlab = "", ylab = "", main = "Visualized Log2 Gene Count per Experimental Condition After Filtering Data", labRow = rn, labCol = cn)
```

Expression of the genes for the last condition is low in general. Since we removed the genes with low count, all the rows look pretty active. Condition 8, 12, 21 seems to have lower expression level then all other conditions. 

```{r condition}
colnames(counts_data)[8]
colnames(counts_data)[12]
colnames(counts_data)[21]
colnames(counts_data)[31]
```

Box plot with reference with lecture 5 normalization codes after data filtering.

```{r boxplot}
boxplot(x_log, xlab = "Samples", ylab = "log2 TPM",
las = 2, cex = 0.5, cex.lab = 0.5,
cex.axis = 0.5, main = "Experimental conditions expression log2 TPM")

abline(h = median(apply(x_log, 2, median)),
col = "red", lwd = 0.6, lty = "dashed")
```

Density plot with reference to lecture 5 normalization codes. Before normalization. 

```{r density_before, fig.height = 12, fig.width = 22}
counts_density <- apply(log2(subset_data), 2, density)

xlim <- 0; ylim <- 0
for (i in 1:length(counts_density)) {
xlim <- range(c(xlim, counts_density[[i]]$x));
ylim <- range(c(ylim, counts_density[[i]]$y))
}
cols <- rainbow(length(counts_density))
ltys <- rep(1, length(counts_density))


plot(counts_density[[1]], xlim=xlim, ylim=ylim, type="n",
ylab="Smoothing density of log2-CPM Before normalization",
main="", cex.lab = 0.85)

for (i in 1:length(counts_density))
lines(counts_density[[i]], col=cols[i], lty=ltys[i])
#create legend
legend("topright", colnames(subset_data),
col=cols, lty=ltys, cex=0.75,
border ="blue", text.col = "green4",
merge = TRUE, bg = "gray90")
```

It seems like my data does not follow a normal distribution, rather, an anti-symmetry distribution is observed.There is a sample that lies completely to the left side. Perhaps it is the NTC sample. 

## Data Normalization

### Apply Trimmed Mean of M-values to counts_data based on Samples
With reference to lecture 5.

Data grouping according to sample. Added cell line from Assignment 1 for investigation.
```{r grouping}
sample_groups <- unlist(lapply(c(rep("808.3", 3), rep("808.5", 3), rep("G92C", 3), rep("P118L", 3), rep("R138Q", 3), rep("R168H.D7.14", 3), rep("R291W", 3), rep("R168H.RG.Un", 3), rep("R168H.RG.Pro", 3)), identity))
sample_groups <- append(sample_groups, "NTC")

rep <- rep(c(1, 2, 3), times = 9) 
rep <- append(rep, 1)

cell_line <- unlist(lapply(c(rep("iPSC", 21), rep("Human Sample", 6)), identity))
cell_line <- append(cell_line, "iPSC")

exp_groups <- cbind(colnames(subset_data), sample_groups, rep, cell_line)

exp_groups <- data.frame(sample_group = sample_groups, replication = rep, cell_line=cell_line)
exp_groups
```

```{r TMM}
d = DGEList(counts=as.matrix(subset_data), group=exp_groups$sample_groups)
d = calcNormFactors(d)
normalized_count_data <- cpm(d)
```

Box plot with reference with lecture 5 normalization codes after normalization. The median aligned together except for the last condition NTC. Normalization successfully applied to the data.
```{r boxplot_after_norm}
x_log <- log2(normalized_count_data)
x_log[which(x_log == -Inf)] <- 0

boxplot(x_log, xlab = "Samples", ylab = "log2 TPM",
las = 2, cex = 0.5, cex.lab = 0.5,
cex.axis = 0.5, main = "Experimental conditions expression log2 TPM After Normalization")

abline(h = median(apply(x_log, 2, median)),
col = "red", lwd = 0.6, lty = "dashed")
```

Density plot with reference to lecture 5 normalization codes.
```{r density_after, fig.height = 12, fig.width = 22}
counts_density <- apply(log2(normalized_count_data), 2, density)

xlim <- 0; ylim <- 0
for (i in 1:length(counts_density)) {
xlim <- range(c(xlim, counts_density[[i]]$x));
ylim <- range(c(ylim, counts_density[[i]]$y))
}
cols <- rainbow(length(counts_density))
ltys <- rep(1, length(counts_density))


plot(counts_density[[1]], xlim=xlim, ylim=ylim, type="n",
ylab="Smoothing density of log2-CPM After normalization",
main="", cex.lab = 0.85)

for (i in 1:length(counts_density))
lines(counts_density[[i]], col=cols[i], lty=ltys[i])
#create legend
legend("topright", colnames(subset_data),
col=cols, lty=ltys, cex=0.75,
border ="blue", text.col = "green4",
merge = TRUE, bg = "gray90")
```
The data looks more centered after normalization. 

# Continued Data Exloration Journey

### MDS plot
I have not included this plot in the previous assignment.Plotted with reference to lecture 5. 
```{r MDS_condition, fig.height = 8, fig.width = 8}
colors_plot<- sample(colors()[1:657], 10)

limma::plotMDS(normalized_count_data, labels=NULL,pch=1, cex=0.8,
col = colors_plot[factor(exp_groups$sample_group)], main = "Multidimensional Scaling (MDS) after normalization group by mutation condition")

legend("top",
legend=levels(factor(exp_groups$sample_group)),
pch=c(1), col=
colors_plot,title="Class",
bty = 'n', cex = 0.75)
```
The data is separted into NTC and non NTC according to the MDS graph. 

```{r MDS_bio_rep, fig.height = 8, fig.width = 8}
colors_plot<- c("red3", "green2", "blue2")
limma::plotMDS(normalized_count_data, labels=NULL,pch=1, cex=0.8,
col = colors_plot[factor(exp_groups$replication)], main = "Multidimensional Scaling (MDS) after normalization group by bio-replicate num")

legend("top",
legend=levels(factor(exp_groups$replication)),
pch=c(1), col=
colors_plot,title="Class",
bty = 'n', cex = 0.75)
```
No significant difference showned. The 1 at the left hand side is of type NTc. 

```{r MDS_cell_line, fig.height = 8, fig.width = 8}
colors_plot<- c("red3", "blue2")

limma::plotMDS(normalized_count_data, labels=NULL,pch=1, cex=1,
col = colors_plot[factor(exp_groups$cell_line)], main = "Multidimensional Scaling (MDS) after normalization group by Cell Line")

legend("top",
legend=levels(factor(exp_groups$cell_line)),
pch=c(1), col=
colors_plot,title="Class",
bty = 'n', cex = 0.75)
```
Seems like the sample from human donor has higher expression in general than iPSC cell line. Interesting observation.

## Differetnail Gene Expression
```{r p_value, results='hide'}
model_design <- model.matrix(~exp_groups$sample_group)

expressionMatrix <- as.matrix(normalized_count_data)
rownames(expressionMatrix) < counts_data$Gene.ID
colnames(expressionMatrix) <- colnames(normalized_count_data)
minimalSet <- ExpressionSet(assayData=expressionMatrix)

fit <- lmFit(minimalSet, model_design)
fit2 <- eBayes(fit,trend=TRUE)

topfit <- topTable(fit2,
coef=ncol(model_design),
adjust.method = "BH",
number = nrow(expressionMatrix))


output_hits <- merge(data.frame(counts_data$Gene.ID, counts_data$Gene.Name), topfit, by.y=0, by.x=1, all.y=TRUE)
output_hits <- output_hits[order(output_hits$P.Value),]

```

```{r table}
kable(head(output_hits),type="html",row.names = FALSE)
```


```{r p_value_pass}
length(which(output_hits$P.Value < 0.05)) # passed p-value<0.05 threshold
length(which(output_hits$adj.P.Val < 0.05)) # passed adjacent f-value < 0.05 threshold
```
Model 2 with cell line as variable that is taken into consideration
```{r model2}
model_design_pat2 <- model.matrix(~exp_groups$cell_line)
fit_pat <- lmFit(minimalSet, model_design_pat2)
fit_pat2 <- eBayes(fit_pat,trend=TRUE)

topfit <- topTable(fit_pat2,
coef=ncol(model_design_pat2),
adjust.method = "BH",
number = nrow(expressionMatrix))


output_hits2 <- merge(data.frame(counts_data$Gene.ID, counts_data$Gene.Name), topfit, by.y=0, by.x=1, all.y=TRUE)
output_hits2 <- output_hits2[order(output_hits2$P.Value),]
```

```{r table2}
kable(head(output_hits2),type="html",row.names = FALSE)
```


```{r p_value_pass2}
length(which(output_hits2$P.Value < 0.05)) # passed p-value<0.05 threshold
length(which(output_hits2$adj.P.Val < 0.05)) # passed adjacent f-value < 0.05 threshold
```
A lot more genes pass the threshold using this model. However, the context of using condition to group makes more sense for our purposes. 

```{r compare_model1_2}
model1_pvalues <- data.frame(
  ensembl_id =output_hits$counts_data.Gene.ID,
simple_pvalue=output_hits$P.Value)

model2_pvalues <- data.frame(
  ensembl_id =output_hits2$counts_data.Gene.ID,
patient_pvalue = output_hits2$P.Value)

two_models_pvalues <- merge(model1_pvalues,
model2_pvalues,by.x=1,by.y=1)
two_models_pvalues$colour <- "black"
two_models_pvalues$colour[
two_models_pvalues$simple_pvalue<0.05] <- "orange"
two_models_pvalues$colour[
two_models_pvalues$patient_pvalue<0.05] <- "blue"
two_models_pvalues$colour[
two_models_pvalues$simple_pvalue<0.05 &
two_models_pvalues$patient_pvalue<0.05] <- "red"

plot(two_models_pvalues$simple_pvalue,
two_models_pvalues$patient_pvalue,
col = two_models_pvalues$colour,
xlab = "condition model p-values",
ylab ="cell line model p-values",
main="Condition vs cell line Limma p-value Method")
```
```{r}
p.adjust.methods
```


### MA or Volcano Plot

### Top hit genes Heatmap

## Thresholded over-representation analysis (ORA)

### Method chosen
### Up-regualted versus down regulated gene sets
```{r up_down_regualtion}
# length(which(qlf_output_hits$table$PValue < 0.05
# & qlf_output_hits$table$logFC > 0))
# 
# length(which(qlf_output_hits$table$PValue < 0.05
# & qlf_output_hits$table$logFC < 0))
```

## Intrepretation - Questions and answers

#### 1.	Do the over-representation results support conclusions or mechanism discussed in the original paper?
#### 2.	Can you find evidence, i.e. publications, to support some of the results that you see. How does this evidence support your results.


## Citations (if any)

Lecture 4 BCB420 by Professor Ruth Isserlin. 

https://bioconductor.org/packages/release/bioc/html/GEOquery.html
